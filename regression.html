<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Linear Regression Interactive Demo</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#38bdf8;
    --muted:#94a3b8;
    --card:#0b1220;
    --green:#34d399;
    --red:#fb7185;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#071024 0%, #071a2a 100%);color:#e6eef8}
  .container{max-width:1100px;margin:28px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
  h1{margin:0 0 12px;font-size:20px;color:var(--accent)}
  .grid{display:grid;grid-template-columns:360px 1fr;gap:18px}
  .panel{background:var(--card);padding:14px;border-radius:10px}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  input[type="text"], input[type="number"]{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .row{display:flex;gap:8px;align-items:center}
  .controls{display:flex;flex-direction:column;gap:12px}
  button{background:var(--accent);border:none;color:#042033;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  canvas{width:100%;height:600px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));display:block}
  .small{font-size:13px;color:var(--muted)}
  .info{margin-top:12px;padding:10px;border-radius:8px;background:var(--glass);font-size:13px}
  .stat{display:flex;justify-content:space-between;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.01);margin-top:8px}
  .flex{display:flex;gap:8px;align-items:center}
  .slider{width:160px}
  .muted{color:var(--muted)}
  .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .legend .item{display:flex;gap:6px;align-items:center;font-size:13px}
  .swatch{width:14px;height:10px;border-radius:3px}
  .swatch.line{background:linear-gradient(90deg,var(--accent),#60a5fa)}
  .swatch.point{background:var(--green)}
  .swatch.pred{background:#f59e0b}
  .swatch.vec{background:#a78bfa}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  @media(max-width:900px){.grid{grid-template-columns:1fr;}.panel{order:2}}
</style>
</head>
<body>
<div class="container">
  <h1>Linear Regression Interactive Demo</h1>
  <div class="grid">
    <div class="panel">
      <div class="controls">
        <div>
          <label>X values comma separated</label>
          <input id="xInput" type="text" placeholder="e.g. 1,2,3,4,5" value="1,2,3,4,5" />
        </div>
        <div>
          <label>Y values comma separated</label>
          <input id="yInput" type="text" placeholder="e.g. 2,4,6,8,10" value="2,4,6,8,10" />
        </div>
        <div class="row">
          <button id="plotBtn">Plot</button>
          <button id="randomBtn" style="background:var(--green)">Randomize</button>
          <button id="resetBtn" style="background:var(--red)">Reset</button>
        </div>

        <div>
          <label>Weight</label>
          <div class="row">
            <input id="weightRange" class="slider" type="range" min="-5" max="5" step="0.01" value="1" />
            <input id="weightNum" type="number" step="0.01" value="1" style="width:90px" />
          </div>
        </div>

        <div>
          <label>Bias</label>
          <div class="row">
            <input id="biasRange" class="slider" type="range" min="-20" max="20" step="0.1" value="0" />
            <input id="biasNum" type="number" step="0.1" value="0" style="width:90px" />
          </div>
        </div>

        <div class="info">
          <div class="small">Click a point on the canvas to inspect the mapping and dot product.</div>
          <div class="stat"><div class="muted">Selected X</div><div id="selX">—</div></div>
          <div class="stat"><div class="muted">Actual Y</div><div id="selY">—</div></div>
          <div class="stat"><div class="muted">Predicted y = w·x + b</div><div id="predY">—</div></div>
          <div class="stat"><div class="muted">Dot product w·x</div><div id="dotProd">—</div></div>
          <div class="stat"><div class="muted">Rise</div><div id="rise">—</div></div>
          <div class="stat"><div class="muted">Run</div><div id="run">—</div></div>
        </div>

        <div class="legend">
          <div class="item"><span class="swatch line"></span> Model line</div>
          <div class="item"><span class="swatch point"></span> Data points</div>
          <div class="item"><span class="swatch pred"></span> Predicted points</div>
          <div class="item"><span class="swatch vec"></span> Transformation vector</div>
        </div>

        <div class="footer">This demo shows the linear map \(x \mapsto w\cdot x + b\). The dot product here is the scalar product of weight and input for a single feature.</div>
      </div>
    </div>

    <div class="panel" style="padding:12px">
      <canvas id="plot" width="800" height="600"></canvas>
    </div>
  </div>
</div>

<script>
/* Linear Regression Interactive Demo
   - Single-feature linear model: y_hat = w * x + b
   - Click a point to inspect dot product and rise/run
*/

const canvas = document.getElementById('plot');
const ctx = canvas.getContext('2d');

const xInput = document.getElementById('xInput');
const yInput = document.getElementById('yInput');
const plotBtn = document.getElementById('plotBtn');
const randomBtn = document.getElementById('randomBtn');
const resetBtn = document.getElementById('resetBtn');

const weightRange = document.getElementById('weightRange');
const weightNum = document.getElementById('weightNum');
const biasRange = document.getElementById('biasRange');
const biasNum = document.getElementById('biasNum');

const selX = document.getElementById('selX');
const selY = document.getElementById('selY');
const predY = document.getElementById('predY');
const dotProd = document.getElementById('dotProd');
const riseEl = document.getElementById('rise');
const runEl = document.getElementById('run');

let data = { x: [1,2,3,4,5], y: [2,4,6,8,10] };
let w = parseFloat(weightRange.value);
let b = parseFloat(biasRange.value);
let selectedIndex = null;

// coordinate transform
const padding = 50;
function computeBounds() {
  const xs = data.x.slice();
  const ys = data.y.slice();
  if (xs.length === 0) return {xmin:0,xmax:1,ymin:0,ymax:1};
  const xmin = Math.min(...xs);
  const xmax = Math.max(...xs);
  const ymin = Math.min(...ys);
  const ymax = Math.max(...ys);
  // expand a bit
  const xpad = (xmax - xmin) * 0.2 || 1;
  const ypad = (ymax - ymin) * 0.2 || 1;
  return { xmin: xmin - xpad, xmax: xmax + xpad, ymin: ymin - ypad, ymax: ymax + ypad };
}
function xToCanvas(x, bounds) {
  const wCanvas = canvas.width - padding*2;
  return padding + (x - bounds.xmin) / (bounds.xmax - bounds.xmin) * wCanvas;
}
function yToCanvas(y, bounds) {
  const hCanvas = canvas.height - padding*2;
  // invert y
  return padding + (bounds.ymax - y) / (bounds.ymax - bounds.ymin) * hCanvas;
}
function canvasToData(cx, cy, bounds) {
  const wCanvas = canvas.width - padding*2;
  const hCanvas = canvas.height - padding*2;
  const x = bounds.xmin + (cx - padding) / wCanvas * (bounds.xmax - bounds.xmin);
  const y = bounds.ymax - (cy - padding) / hCanvas * (bounds.ymax - bounds.ymin);
  return {x,y};
}

function clear() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

function drawAxes(bounds) {
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  // x axis
  const y0 = yToCanvas(0, bounds);
  ctx.moveTo(padding, y0);
  ctx.lineTo(canvas.width - padding, y0);
  // y axis
  const x0 = xToCanvas(0, bounds);
  ctx.moveTo(x0, padding);
  ctx.lineTo(x0, canvas.height - padding);
  ctx.stroke();

  // ticks and labels
  ctx.fillStyle = 'rgba(230,238,248,0.7)';
  ctx.font = '12px system-ui, Arial';
  // x ticks
  const xRange = bounds.xmax - bounds.xmin;
  const xStep = niceStep(xRange);
  for (let v = Math.ceil(bounds.xmin/xStep)*xStep; v <= bounds.xmax; v += xStep) {
    const cx = xToCanvas(v, bounds);
    ctx.beginPath();
    ctx.moveTo(cx, canvas.height - padding);
    ctx.lineTo(cx, canvas.height - padding + 6);
    ctx.stroke();
    ctx.fillText(round(v,2), cx-10, canvas.height - padding + 20);
  }
  // y ticks
  const yRange = bounds.ymax - bounds.ymin;
  const yStep = niceStep(yRange);
  for (let v = Math.ceil(bounds.ymin/yStep)*yStep; v <= bounds.ymax; v += yStep) {
    const cy = yToCanvas(v, bounds);
    ctx.beginPath();
    ctx.moveTo(padding-6, cy);
    ctx.lineTo(padding, cy);
    ctx.stroke();
    ctx.fillText(round(v,2), 6, cy+4);
  }
}

function niceStep(range) {
  // simple nice step heuristic
  const rough = range / 6;
  const pow = Math.pow(10, Math.floor(Math.log10(rough)));
  const norm = rough / pow;
  let step = pow;
  if (norm < 1.5) step = 1 * pow;
  else if (norm < 3) step = 2 * pow;
  else if (norm < 7) step = 5 * pow;
  else step = 10 * pow;
  return step;
}

function round(v, d=2) {
  return Math.round(v * Math.pow(10,d)) / Math.pow(10,d);
}

function draw() {
  clear();
  const bounds = computeBounds();
  drawAxes(bounds);

  // draw model line
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(56,189,248,0.95)'; // accent
  ctx.beginPath();
  // compute two points at xmin and xmax
  const x1 = bounds.xmin;
  const x2 = bounds.xmax;
  const y1 = w * x1 + b;
  const y2 = w * x2 + b;
  ctx.moveTo(xToCanvas(x1,bounds), yToCanvas(y1,bounds));
  ctx.lineTo(xToCanvas(x2,bounds), yToCanvas(y2,bounds));
  ctx.stroke();

  // draw data points and predicted points
  for (let i=0;i<data.x.length;i++){
    const xi = data.x[i];
    const yi = data.y[i];
    const px = xToCanvas(xi,bounds);
    const py = yToCanvas(yi,bounds);
    // actual point
    ctx.fillStyle = 'rgba(52,211,153,0.95)'; // green
    ctx.beginPath();
    ctx.arc(px,py,6,0,Math.PI*2);
    ctx.fill();
    // predicted
    const yhat = w*xi + b;
    const ppx = xToCanvas(xi,bounds);
    const ppy = yToCanvas(yhat,bounds);
    ctx.fillStyle = 'rgba(245,158,11,0.95)'; // orange
    ctx.beginPath();
    ctx.arc(ppx,ppy,4,0,Math.PI*2);
    ctx.fill();

    // if selected, draw transformation vector and rise/run
    if (selectedIndex === i) {
      // vector from (xi, yhat) to (xi, yi) (vertical rise)
      ctx.strokeStyle = 'rgba(167,139,250,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(ppx,ppy);
      ctx.lineTo(px,py);
      ctx.stroke();

      // draw arrow from (xi,0) up to predicted yhat to show mapping x -> yhat
      const baseX = xToCanvas(xi,bounds);
      const baseY = yToCanvas(0,bounds);
      ctx.strokeStyle = 'rgba(167,139,250,0.6)';
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(ppx, ppy);
      ctx.stroke();
      ctx.setLineDash([]);

      // highlight selected actual point
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px,py,10,0,Math.PI*2);
      ctx.stroke();
    }
  }

  // overlay text: equation
  ctx.fillStyle = 'rgba(230,238,248,0.95)';
  ctx.font = '14px system-ui, Arial';
  ctx.fillText(`Model: y = ${round(w,3)}·x + ${round(b,3)}`, padding, 22);
  ctx.fillStyle = 'rgba(230,238,248,0.6)';
  ctx.font = '12px system-ui, Arial';
  ctx.fillText(`Click a point to inspect dot product and rise/run`, padding, 40);
}

// parse input arrays
function parseArray(str) {
  if (!str) return [];
  return str.split(',').map(s => parseFloat(s.trim())).filter(v => !Number.isNaN(v));
}

function updateDataFromInputs() {
  const xs = parseArray(xInput.value);
  const ys = parseArray(yInput.value);
  if (xs.length !== ys.length) {
    // if lengths mismatch, try to pair up to min length
    const n = Math.min(xs.length, ys.length);
    data.x = xs.slice(0,n);
    data.y = ys.slice(0,n);
  } else {
    data.x = xs;
    data.y = ys;
  }
  selectedIndex = null;
  updateInfo();
  draw();
}

function updateInfo() {
  if (selectedIndex === null) {
    selX.textContent = '—';
    selY.textContent = '—';
    predY.textContent = '—';
    dotProd.textContent = '—';
    riseEl.textContent = '—';
    runEl.textContent = '—';
  } else {
    const xi = data.x[selectedIndex];
    const yi = data.y[selectedIndex];
    const yhat = w*xi + b;
    selX.textContent = round(xi,4);
    selY.textContent = round(yi,4);
    predY.textContent = round(yhat,4);
    dotProd.textContent = `${round(w,4)} · ${round(xi,4)} = ${round(w*xi,4)}`;
    const rise = yi - yhat;
    const run = 0; // for vertical difference run is 0; but we can show horizontal run between x and x (0)
    // For slope interpretation show rise/run between two points on model: use small dx
    const dx = 1;
    const slopeRise = w * dx;
    riseEl.textContent = `actual - pred = ${round(rise,4)}; slope rise for dx=1 is ${round(slopeRise,4)}`;
    runEl.textContent = `run = ${round(dx,4)} (for slope visualization)`;
  }
}

// event handlers
plotBtn.addEventListener('click', () => {
  updateDataFromInputs();
});

randomBtn.addEventListener('click', () => {
  // generate random linear-ish data
  const n = 8;
  const trueW = (Math.random()*4 - 2);
  const trueB = (Math.random()*10 - 5);
  const xs = [];
  const ys = [];
  for (let i=0;i<n;i++){
    const x = round(i + Math.random()*2,3);
    const noise = (Math.random()-0.5)*3;
    const y = trueW * x + trueB + noise;
    xs.push(round(x,3));
    ys.push(round(y,3));
  }
  xInput.value = xs.join(',');
  yInput.value = ys.join(',');
  updateDataFromInputs();
});

resetBtn.addEventListener('click', () => {
  xInput.value = '1,2,3,4,5';
  yInput.value = '2,4,6,8,10';
  weightRange.value = 1; weightNum.value = 1;
  biasRange.value = 0; biasNum.value = 0;
  w = 1; b = 0;
  updateDataFromInputs();
});

weightRange.addEventListener('input', (e) => {
  w = parseFloat(e.target.value);
  weightNum.value = w;
  draw();
  updateInfo();
});
weightNum.addEventListener('change', (e) => {
  w = parseFloat(e.target.value);
  weightRange.value = w;
  draw();
  updateInfo();
});
biasRange.addEventListener('input', (e) => {
  b = parseFloat(e.target.value);
  biasNum.value = b;
  draw();
  updateInfo();
});
biasNum.addEventListener('change', (e) => {
  b = parseFloat(e.target.value);
  biasRange.value = b;
  draw();
  updateInfo();
});

// canvas click to select nearest point
canvas.addEventListener('click', (ev) => {
  const rect = canvas.getBoundingClientRect();
  const cx = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const cy = (ev.clientY - rect.top) * (canvas.height / rect.height);
  const bounds = computeBounds();
  let best = {idx:null,dist:Infinity};
  for (let i=0;i<data.x.length;i++){
    const px = xToCanvas(data.x[i],bounds);
    const py = yToCanvas(data.y[i],bounds);
    const d = Math.hypot(px - cx, py - cy);
    if (d < best.dist) { best = {idx:i,dist:d}; }
  }
  if (best.dist < 20) {
    selectedIndex = best.idx;
  } else {
    selectedIndex = null;
  }
  updateInfo();
  draw();
});

// initial draw
updateDataFromInputs();
draw();
</script>
</body>
</html>
